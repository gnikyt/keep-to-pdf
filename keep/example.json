{"color":"DEFAULT","isTrashed":false,"isPinned":false,"isArchived":false,"annotations":[{"description":"Reusable components can be shared across multiple domains of your application to avoid duplication through HOCs, children prop, functionAsChildren patterns.","source":"WEBLINK","title":"Composition Patterns in React.js, higher-order-components, children pr","url":"https://blog.henzzo.com/composition-patterns-in-reactjs"}],"textContent":"eusing functions is one of our goals as developers, and React makes it easy to create reusable components. Reusable components can be shared across multiple domains of your application to avoid duplication. We will cover the following topics:\n\n-   How components communicate with each other using props and children\n-   The container and presentational patterns and how they can make our code more maintainable\n-   What higher-order components (HOCs) are and how, thanks to them, we can structure our applications in a better way\n-   What the function of the child component pattern is and what its benefits are\n\nLets start with a code example:\n\n```\n\nexport default function App(){\n    const [counter, setCounter] = useState(0);\n\n    const incrementCounter = () => setCounter(prevValue => prevValue+1)\n\n    return (\n         <div className=\"m-2 text-center\">\n            <Message theme=\"primary\" message={ `Counter: ${this.state.counter}`} />\n\n            <ActionButton theme=\"secondary\" text=\"Increment\" \n                           callback={ this.incrementCounter } />\n        <\/div>\n    )\n}\n\n\nexport function Message({theme, message}) {\n\n    return (\n        <div className={`h5 bg-${theme} text-white p-2`}>\n            {message }\n        <\/div>\n    )\n}\n\n\nexport const ActionButton = ({theme, text,  callback}) => {\n\n    return (\n        <button className={` btn btn-${theme} m-2` } onClick={callback} >\n            { text }\n        <\/button>\n    )\n}\n\n```\n\nWhich give use this output:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646656580629/Nup5euZqd.png?auto=compress,format&format=webp)\n\nThe above components are very simple, But they illustrate the basic relationship that underpins React philosophy: Parent component(owners) configure children with data props and receive notification through function props, Which triggers an update process in case of state data change.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646289179990/bwz49JB3S.png?auto=compress,format&format=webp)\n\nThis pattern is easy to understand in a simple example, but its use in more complex situations can be less obvious, and it can be hard to know how to locate and distribute the state data, props, and callbacks without duplicating code and data.\n\n### Using the Children Prop\n\nReact provides a special `children` prop that is used when a component needs to display content provided by its parent (owner) component but doesn\u2019t know what that content will be in advance. In the React documentation, it is described as opaque because it is a property that does not tell you anything about the value it contains. This is a useful way of reducing duplication of the component by standardizing features in that component that can be reused across an application.\n\nSo that means Components can also be defined with nested components inside them, and they can access those nested components using the `children` prop. To demonstrate, let create a `ThemeSelector` component that handles local theming for the above example.\n\n```\n\nexport function ThemeSelector({children}) {\n    return (\n        <div className=\"bg-dark p-2\">\n            <div className=\"bg-info p-2\">\n                { children }  // render whatever component passed as child\n            <\/div>\n        <\/div>\n    )\n}\n\n\nimport {ThemeSelector} from \"./ThemeSelector\";\nexport default function App(){\n   ....\n\n    return (\n         <div className=\"m-2 text-center\">\n            <ThemeSelector>\n                <Message theme=\"primary\" message={`Counter: ${counter}`} />\n                <Button theme=\"secondary\" text=\"Increment\"\n                               callback={ incrementCounter } />\n            <\/ThemeSelector>\n\n        <\/div>\n    )\n}\n\n```\n\nThe `App` component provides content for the `ThemeSelector` component by defining elements between its start and end tags. In this case `Message` and `ActionButton` components. When React processes the content rendered by the `App` component, the content between the `ThemeSelector` tags is assigned to the `children` prop, The `ThemeSelector` use `bg-dark` Bootstrap background class producing the result shown:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646656632347/lqwJqG6P3.png?auto=compress,format&format=webp)\n\n### Adding `Props` to components received through the `children` prop.\n\nThis is not an ideal or recommended way to pass props to child components, I mentioned it in case you got stuck working with the `children` prop only and also to let you know about React Top-Level APIs methods.\n\nAs we said earlier component can\u2019t manipulate the content it receives from the parent directly, so to provide the components received through the children prop with additional data or functions, the `React.Children.map` method is used in conjunction with the `React.cloneElement` method to duplicate the child components and assign additional props. Those are React Top-Level APIs methods.\n\nLet's add a `select` html element to the content rendered by the`ThemeSelector` that updates a state and allows a user to choose one of the theme colors provided by the Bootstrap CSS framework, which is then passed on to the container\u2019s children as a prop using those Top-Level APIs.\n\n```\nexport function ThemeSelector({ children }) {\n\n    const themes = [\"primary\", \"secondary\", \"success\", \"warning\", \"dark\"];\n    const [theme, setTheme] = useState('primary')\n\n    \n    const changeTheme = (event) => setTheme(event.target.value);\n\n    \n     \n    const childrenWithTheme = React.Children.map(children, child => \n              React.cloneElement(child, { theme }))\n\n\n    return (\n        <div className=\"bg-dark p-2\">\n\n            <div className=\"form-group text-left\">\n                <label className=\"text-white\">Theme:<\/label>\n                <select className=\"form-control\" value={theme}\n                        onChange={changeTheme}>\n                    {themes.map(theme => <option key={theme} value={theme}>{theme}<\/option>)}\n                <\/select>\n            <\/div>\n\n            <div className=\"bg-info p-2\">\n                {childrenWithTheme} \n            <\/div>\n        <\/div>\n    )\n}\n\n```\n\nBecause props are read-only, we can\u2019t use the `React.Children.forEach` method to simply enumerate the child components and assign a new property to their props object. Instead, I used the map method to enumerate the children and used the `React.cloneElement` method to duplicate each child with an additional prop.\n\n`React.cloneElement(c, { theme: this.state.theme})` The `cloneElement` method accepts a child component and a props object, which is merged with the child component\u2019s existing props.\n\nThe result is that the props passed to the `Message` and `ActionButton` components are a combination of those defined by the `App` component and those added using the `cloneElement` method by the `ThemeSelector` component. When you choose a theme from the select element, an update is performed, and the selected theme is applied to the `Message` and `ActionButton` components, as shown:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646656662598/s9Yeb8jDZ.png?auto=compress,format&format=webp)\n\nThere is a famous saying you hear everywhere in react community: You should avoid writing coupled components, your component should be reusable, and maintainable! but how?\n\nOne thinking that helps me to grasp that rule is that React components typically contain a mix of **_logic_** and **_presentation_**. By _Logic_ I refer to anything that is unrelated to the UI, These are API calls, data manipulation, heavy computations, and event handlers. The _Presentation_ is the part inside `render` where we create the elements to be displayed to the UI. In React, there are simple and powerful patterns, known as **container and presentational**, which we can apply when creating components that help us to separate those two concerns. Let's see an example:\n\n```\n\nexport default function CoolQuotes() {\n    const [quote, setQuote] = useState({quote: '...loading'});\n\n    useEffect(() => {\n        refreshQuote()\n    }, [])\n\n    const refreshQuote = () => {\n        fetch('https://api.kanye.rest')\n            .then(res => res.json())\n            .then(setQuote)\n    }\n\n    return (\n       <div className='rounded bg-light mt-5 p-3 mx-4'>\n            <button className=\"btn btn-info\" onClick={refreshQuote}>refresh<\/button>\n\n            <p className='m-4'>\n                {quote.quote}\n            <\/p>\n        <\/div>\n    )\n}\n\n```\n\nThe above code give us: ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646656983114/AbNTfT97v.png?auto=compress,format&format=webp)\n\nIn the above example am using a cool \"API\" by [Andrew Jazbec](https://github.com/ajzbc/kanye.rest) that serves quotes of Kanye. After the first render we send `fetch` request to ['https://api.kanye.rest'](https://blog.henzzo.com/'https://api.kanye.rest'), convert the response to `.json()` and set the local state which then rerender the fetched data.\n\nNow, this component does not have any problems, and it works as expected. But wouldn't it be nice to separate the `fetch` logic from the part where the result is presented to make it clean? We will use the container and presentational patterns to isolate the two.\n\nThe container knows everything about the logic of the component and is where the APIs are called. It also deals with data manipulation and event handling.\n\nThe presentational component is where the UI is defined, and it receives data in the form of props from the container. Since the presentational component is usually logic-free, we can create it as a functional, stateless component. There are no rules that say that the presentational component must not have a state (for example, it could keep a UI state inside it). Let's extract those two:\n\n```\n\nexport const CoolQuoteContainer = () => {\n    const [quoteData, setQuoteData] = useState({quote: '...loading'});\n\n    useEffect(() => {\n        refreshQuote()\n    }, [])\n\n    const refreshQuote = () => {\n        fetch('https://api.kanye.rest')\n            .then(res => res.json())\n            .then(setQuoteData)\n    }\n\n    return <CoolQuote quote={quoteData.quote} onRefresh={refreshQuote} />;\n}\n\n\n\nexport const CoolQuote = ({quote, onRefresh}) => {\n    return (\n        <div className='rounded bg-light mt-5 p-3 mx-4'>\n            <button className=\"btn btn-info\" onClick={onRefresh}>refresh<\/button>\n            <p className='m-4'> {quote} <\/p>\n        <\/div>\n    )\n}\n\n```\n\nI renamed `CoolQuote` component to `CoolQuoteContainer`, this rule is not strict, but it is widely used in the React community to append `Container` to the end of the `Container` component name and give the original name to the presentational one.\n\nAs you can see in the preceding snippet, instead of creating the HTML elements inside the return of the container, we just use the presentational one and pass the state (`quote` and `onRefresh`) to it.\n\nCreating well-defined boundaries between logic and presentation not only makes components more reusable, but also provides many other benefits like,\n\n-   We can pass a dummy or placeholder data and put it in other places that need to display the same data structure,\n-   Other developers in our team can improve the container that uses the API by adding some error-handling logic, without affecting its presentation.\n-   They can even build a temporary presentational component just to display and debug data and then replace it with the real presentational component when it is ready.\n\n### What is the cue to use it?\n\nApplying this pattern without a real reason can give us the opposite problem and make the code base less useful as it involves the creation of more files and components. In general, the right path to follow is **_starting with a single component and splitting it only when the logic and the presentation become too coupled_** .\n\nIn our example, we began from a single component, and we realized that we could separate the API call from the markup. Deciding what to put in the container and what goes into the presentation is not always straightforward; the following points should help you make that decision:\n\nThe following are the characteristics of container components:\n\n-   They are more concerned with behavior.\n-   They render their presentational components.\n-   They make API calls and manipulate data.\n-   They define event handlers.\n\nThe following are the characteristics of presentational components:\n\n-   They are more concerned with the visual representation.\n-   They render the HTML markup (or other components).\n-   They receive data from the parents in the form of props.\n-   They are often written as stateless functional components.\n\nConceptually, components are like JavaScript `functions`. They accept arbitrary inputs (called `props`) and return React elements describing what should appear on the screen.\n\nSo, we can say that a component is a `function` of some data passed via `props`. Therefore, we can continue this analogy with functions and extend it. What would a Higher Order Component be?\n\nSince a higher-order function either takes a `function` or returns a `function` or both, we can assume that a higher-order component is one that takes a component and returns another one as a result. This is what the official docs tell us.\n\n`HOCs` are like _higher-order functions_ but in the realm of React components. While a component transforms `props` into `UI`, a higher-order component transforms a component into another component, enhanced in some way. They are a literal implementation of a [Decorator pattern.](https://en.wikipedia.org/wiki/Decorator_pattern)\n\n`const HoC = Component => EnhancedComponent`\n\nLet's add some additional functionality to the `CoolQuote` component to see `HOC` in action. If the user is a Pro member, we enable the feature to see the author of the quote and will get nice background(see `Bootstrap` class `bg-info` in side the `withFetch` hoc), if it's a logged-in user we want them able to share the tweet on Twitter. Otherwise only refresh the quote. Let's change the previous example to fit with `HOC` and we will go through it.\n\n```\n\nexport const CoolQuote = ({quote, onRefresh, author, loggedIn}) => {\n    return (\n        <div className='rounded mt-5 p-3'>\n            <button className=\"btn btn-info\" onClick={onRefresh}>refresh<\/button>\n\n             {loggedIn && <a className=\"btn btn-primary ml-2\"\n                                     href={`https://twitter.com/intent/tweet?text=${quote}`}> \n                                         Tweet\n                               <\/a>}\n\n            <p className='m-4'>\" {quote} \"<\/p>\n\n            {author && <span className='bg-light p-2'>Author --: <i>{author}<\/i><\/span> }\n        <\/div>\n    )\n}\n\n```\n\nEven though we added new functionality to it, we still keep the \"dumbness\"(if it's a word) of it, keeping the logic out of the presentation layer. This give use the following output:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1646657210677/bm_PqIvur.png?auto=compress,format&format=webp)\n\n// change made to the CoolQuoteContainer.js\n\n```\nexport const CoolQuoteContainer = () => {\n    const [isLoggedIn, ] = useState(true);  \n    const [isPro, ] = useState(true);  \n\n    const EnhancedCooQuote = withFetch(CoolQuote);\n\n    return(\n        <EnhancedCooQuote pro={isPro} loggedIn={isLoggedIn}   />\n    );\n\n}\n\n```\n\nWe take the fetching part into the `HOC`(we will see next) and let the container concern only be about user-logins and pro member subscription logic and pass that logic state to the returned component from the `HOC` like `<EnhancedCooQuote pro={isPro} loggedIn={isLoggedIn} />`, which will pass them again along with additional prop to the intended(enhanced) component(see next).\n\nThe part we call the `HOC` like `const EnhancedCooQuote = withFetch(CoolQuote);` and rendering it passing `props` like `return <EnhancedCooQuote pro={isPro} loggedIn={isLoggedIn} />` was a little confusing. Remember after all `HOCs` return a `component` we can pass props or render that `component` , and the `props` we passing is accessed inside that component. Hope it make sense.\n\nLet's see the `HOC` :\n\n```\nconst withFetch = ( Component ) => {\n    return function ( props ){\n\n        const [quote, setQuote] = useState({quote: '...loading'});\n\n        useEffect(() => {\n            refreshQuote()\n        }, [props])\n\n        const refreshQuote = () => {\n            fetch('https://api.kanye.rest')\n                .then(res => res.json())\n                .then(setQuote)\n        }\n\n        return (\n            <div className={props.pro && 'bg-warning  rounded'} >\n                <Component {...props} \n                           author={props.pro && 'kayne west'}\n                           quote={quote.quote}\n                           onRefresh={refreshQuote}/>\n            <\/div>\n        );\n\n    }\n}\n\n```\n\nWe declare a `withFetch` function that takes a `Component` and returns another function. The returned function is a functional component that receives some `props` and renders(wrap) the original `Component`. The collected `props` are spread like `<Component {...props}`. We peeked inside incoming props to include the author prop `author={props.pro && 'Kayne west'}`, we just map `pro -> author`, if a user is Pro then pass the author other wise `undefined`. And also we add background color to the container for Pro users.\n\nThe reason why `HOCs` usually spread the props they receive on the component is because they tend to be transparent and only add the new behavior. Pass unrelated `props` through to the wrapped component. I wrote nice blog about `spread operator` in [this](https://blog.henzzo.com/understanding-rest-parameters-and-spread-operator-in-javascript) article.\n\nThe important part is we are also passing new, additional props `author` and `onRefresh` to the wrapped component and we do not require the component to implement any function. This means that the component and the HOC are not coupled, and they can both be reused across the application. Don't underestimate the power of `props`.\n\nYou may have spotted a pattern in the way `HOCs` are named. It is a common practice to prefix `HOCs` that provide some information to the components they enhance using the `with` pattern. Simply when you're thinking extending some `component` don't mutate the Original Component. Use Composition(`HOcs`).\n\n### When to Use\n\nWe can use `HOCs` when we need to share functionality between many components. Injectors can extend the functionality of a given component by passing new props to it. Sometimes `HOCs` are used for accessing network requests like the above, providing local storage access, subscribing to event streams, or connecting components to an application store. The latter was used in the Redux library to connect a component to the `Reduxstore`. These `HOCs` are often called providers but they work basically the same way.\n\n---\n\nSource: https://blog.henzzo.com/composition-patterns-in-reactjs","title":"Composition Patterns in React.js - Part 1","userEditedTimestampUsec":1658341497918000,"createdTimestampUsec":1658341453278000,"labels":[{"name":"Dev/NodeJS"}]}